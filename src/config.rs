use serde::de::DeserializeOwned;
use serde::Deserialize;

use std::{fs, net, path};

use crate::{Error, ErrorKind, Result};
use crate::{
    CLUSTER_CHAN_SIZE, LISTENER_CHAN_SIZE, MAX_NODES, MIOT_CHAN_SIZE, MQTT_PORT,
    SHARD_CHAN_SIZE,
};

/// Cluster configuration.
#[derive(Clone, Deserialize)]
pub struct Config {
    /// Human readable name of the cluster.
    /// * **Default**: None, must be supplied
    /// * **Mutable**: No
    pub name: String,
    /// Maximum nodes that can exist in this cluster.
    /// * **Default**: [MAX_NODES].
    /// * **Mutable**: No
    pub max_nodes: Option<usize>,
    /// Fixed number of shards, of session/connections, that can exist in this cluster.
    /// Shards are assigned to nodes.
    /// * **Default**: <number of cores in the node>
    /// * **Mutable**: No
    pub num_shards: Option<usize>,
    /// Network listening port for each node in this cluster. Once the cluster is
    /// spawned it will listen on all the available interfaces using this port.
    /// * **Default**: "0.0.0.0:1883", Refer to [MQTT_PORT]
    /// * **Mutable**: No
    pub port: Option<u16>,
    /// Initial set of nodes that are going to be part of this cluster. If not provided
    /// a default node shall be created from `local_address:port`` and created as
    /// single-node cluster.
    /// * **Default**: ["127.0.0.1:1883"]
    /// * **Mutable**: No
    pub nodes: Vec<ConfigNode>,
    /// Input channel size for cluster thread.
    /// * **Default**: [CLUSTER_CHAN_SIZE]
    /// * **Mutable**: No
    pub cluster_chan_size: Option<usize>,
    /// Input channel size for listener thread.
    /// * **Default**: [LISTENER_CHAN_SIZE]
    /// * **Mutable**: No
    pub listener_chan_size: Option<usize>,
    /// Input channel size for shard thread.
    /// * **Default**: [SHARD_CHAN_SIZE]
    /// * **Mutable**: No
    pub shard_chan_size: Option<usize>,
    /// Input channel size for miot thread.
    /// * **Default**: [MIOT_CHAN_SIZE]
    /// * **Mutable**: No
    pub miot_chan_size: Option<usize>,
}

impl Default for Config {
    fn default() -> Config {
        Config {
            name: "poc".to_string(),
            max_nodes: Some(MAX_NODES),
            num_shards: Some(1), // TODO: Some(usize::try_from(num_cpus::get()).unwrap()),
            port: Some(MQTT_PORT),
            nodes: vec![ConfigNode::default()],
            cluster_chan_size: Some(CLUSTER_CHAN_SIZE),
            listener_chan_size: Some(LISTENER_CHAN_SIZE),
            shard_chan_size: Some(SHARD_CHAN_SIZE),
            miot_chan_size: Some(MIOT_CHAN_SIZE),
        }
    }
}

impl Config {
    /// Construct a new configuration from a file located by `loc`.
    pub fn from_file<P>(loc: P) -> Result<Config>
    where
        P: AsRef<path::Path>,
    {
        load_toml(loc)
    }
}

/// Node configuration
#[derive(Clone, Deserialize)]
pub struct ConfigNode {
    /// Address of the node to which clients can connect to.
    pub address: net::SocketAddr,
    /// Weight to be given for each nodes, typically based on the number of cores,
    /// RAM-capacity, network-bandwidth and disk-size.
    /// * **Default**: <number of cores in the node>
    /// * **Mutable**: No
    pub weight: Option<u16>,
    /// Unique identifier for this node within this cluster. There may be other
    /// requirement on the unique-id, like randomness, cyptographic security, public-key.
    /// Refer to package documentation for more detail.
    /// * **Default**: <Shall be generated by the cluster>
    /// * **Mutable**: No
    pub uuid: Option<String>,
}

impl Default for ConfigNode {
    fn default() -> ConfigNode {
        use uuid::Uuid;

        ConfigNode {
            address: "127.0.0.1:1883".parse().unwrap(),
            weight: Some(u16::try_from(num_cpus::get()).unwrap()),
            uuid: Some(Uuid::new_v4().to_string()),
        }
    }
}

fn load_toml<P, T>(loc: P) -> Result<T>
where
    P: AsRef<path::Path>,
    T: DeserializeOwned,
{
    use std::str::from_utf8;

    let ploc: &path::Path = loc.as_ref();
    let data = err!(IOError, try: fs::read(ploc))?;
    let s = err!(FailConvert, try: from_utf8(&data), "not utf8 for {:?}", ploc)?;
    err!(FailConvert, try: toml::from_str(s), "file:{:?}", ploc)
}
